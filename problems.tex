\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[T1]{fontenc}
\usepackage{amssymb,amsmath,graphicx,indentfirst}
\usepackage{caption}
\usepackage{color}
\usepackage{listings}
\usepackage{enumerate}
\usepackage[unicode]{hyperref}

\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\captionsetup[figure]{labelformat=empty}
\captionsetup[figure]{justification=centering}
\lstset{keywordstyle=\color{blue}\bfseries}
\lstset{extendedchars=false, language=Caml, defaultdialect=[Objective]Caml}

\author{Олег Смирнов, Александр Полозов \\
\texttt{oleg.smirnov@gmail.com}, \texttt{polozov.alex@gmail.com}}
\date{\today}
\title{Введение в функциональное программирование -- задачи}

\begin{document}
\section*{Модуль 1. Темы 1.1-1.3}
\begin{enumerate}[{1-}1]
\item Напишите программу, которая выяснит, какой порядок применения функций -–
аппликативный или нормальный –- используется в F\#? То же для любого
императивного языка на ваш выбор. Подумайте, для каких задач какой порядок
применения будет предпочтительнее.

\item Напишите итеративную версию алгоритма быстрого возведения в степень по
формуле
\begin{equation*}
a^k = \left\{
\begin{array}{rl}
a^{k/2} \cdot a^{k/2} &\mbox{\textrm{если} k $\vdots$ 2} \\ 
a \cdot a^{k-1} &\mbox{\textrm{если} k $\not \vdots$ 2}
\end{array}
\right.
\end{equation*}

\item Напишите функцию проверки числа на простоту. Реализуйте рекурсивную и
итеративную версию. Хорошая скорость работы алгоритма -- порядка $O(\sqrt n)$

\item \textbf{*} Нахождение площади фигуры методом Монте-Карло заключается во
вписывании фигуры в прямоугольник и последовательной генерации большого числа
случайно выбранных точек из этого прямоугольника. Итоговой площадью считается
доля точек, попавших в фигуру относительно их общего количества, умноженная на
площадь объемлющего прямоугольника:
\begin{equation*}
  S_\textrm{Ф} = \frac{n_\textrm{внутр}}{n_\textrm{всего}} \cdot S_\textrm{П}
\end{equation*}

Напишите программу, вычисляющую внутреннюю площадь эллипса. В качестве
генератора случайных чисел придумайте какую-то функцию, которая производит 
нетривиальную трансформацию своего аргумента, так что результат функции трудно
предсказуем и варьируется в значительных пределах. Для реализации программы вам
придется хранить начальное значение (seed) своего генератора случайных чисел,
принимать от него при каждом вызове, кроме сгенерированного псевдослучайного
числа, еще и новый seed. Этот seed вы должны будете хранить от вызова к вызову.
\end{enumerate}

\section*{Модуль 2. Темы 2.1-2.3}
\begin{enumerate}[{2-}1]
\item \begin{enumerate}[(a)]
\item Неподвижной точкой функции $f$ называется такое значение $f$, что 
$f(x) = x$. Её можно попробовать найти итеративной последовательностью
приближений:
\begin{equation*}
  x, f(x), f(f(x)), f(f(f(x))), \ldots
\end{equation*}

Напишите процедуру поиска неподвижной точки. Найдите с её помощью значение
золотого сечения $\phi$.

\item Описанный выше метод поиска неподвижной точки может начать осциллировать
и не сойтись, например, если искать $sqrt a$ как неподвижную точку функции
$x \rightarrow \frac{a}{x}$. Тем не менее, можно использовать торможение
усреднением: искать неподвижную точку не функции $f(x)$, а функции
$\frac{x+f(x)}{2}$. Реализуйте этот метод.
\end{enumerate}

\item Напишите функцию fold, которая принимает список элементов, 
функцию-бинарный оператор $op$ и начальное значение $base$, а затем применяет
$op$ к двум аргументам -- к $base$ и к первому элементу списка $x_1$. На
следующем шаге fold применяет $op$ ко результату предыдущей операции и элементу
$x_2$ и так далее, в результате вычисляя формулу:
\begin{equation*}
  op~(\ldots (op~(op~base~x_1)~x_2) \ldots)~x_n
\end{equation*}

\item Напишите функцию dropWhile, которая удаляет самый длинный префикс
(начальную часть) заданного списка, состоящий из элементов, удовлетворяющих
некоторому предикату. В качестве аргументов она принимает предикат и исходный
список, а возвращает новый список. Например:

\begin{lstlisting}
dropWhile (fun x -> x < 5) [1..10]
val it : int list = [5; 6; 7; 8; 9; 10]

dropWhile (fun x -> x > 0) [1; 2; -3; 2; 1]
val it : int list = [-3; 2; 1]

dropWhile (fun x -> x % 2 = 0) [2; 4; 1; 2; 3]
val it : int list = [1; 2; 3]

dropWhile (fun x -> x = 1) [2; 2; 1; 1]
val it : int list = [2; 2; 1; 1]

dropWhile (fun x -> x <> 0) [1..5]
val it : int list = []
\end{lstlisting}

\item \textbf{*} Напишите функцию dropWhile из упражнения 2-3, используя только
функцию fold из упражнения 2-2.
\end{enumerate}

\end{document}
