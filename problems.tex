\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[T1]{fontenc}
\usepackage{amssymb,amsmath,graphicx,indentfirst}
\usepackage{caption}
\usepackage{color}
\usepackage{listings}
\usepackage{enumerate}
\usepackage[unicode]{hyperref}

\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\captionsetup[figure]{labelformat=empty}
\captionsetup[figure]{justification=centering}
\lstset{keywordstyle=\color{blue}\bfseries}
\lstset{extendedchars=false, language=Caml, defaultdialect=[Objective]Caml}

\author{Олег Смирнов, Александр Полозов \\
\texttt{oleg.smirnov@gmail.com}, \texttt{polozov.alex@gmail.com}}
\date{\today}
\title{Введение в функциональное программирование -- задачи}

\begin{document}
\section*{Модуль 1. Темы 1.1-1.3}
\begin{enumerate}[{1-}1]
\item Напишите программу, которая выяснит, какой порядок применения функций -–
аппликативный или нормальный –- используется в F\#? То же для любого
императивного языка на ваш выбор. Подумайте, для каких задач какой порядок
применения будет предпочтительнее.

\item Напишите итеративную версию алгоритма быстрого возведения в степень по
формуле
\begin{equation*}
a^k = \left\{
\begin{array}{rl}
a^{k/2} \cdot a^{k/2} &\mbox{\textrm{если} k $\vdots$ 2} \\ 
a \cdot a^{k-1} &\mbox{\textrm{если} k $\not \vdots$ 2}
\end{array}
\right.
\end{equation*}

\item Напишите функцию проверки числа на простоту. Реализуйте рекурсивную и
итеративную версию. Хорошая скорость работы алгоритма -- порядка $O(\sqrt n)$

\item \textbf{*} Нахождение площади фигуры методом Монте-Карло заключается во
вписывании фигуры в прямоугольник и последовательной генерации большого числа
случайно выбранных точек из этого прямоугольника. Итоговой площадью считается
доля точек, попавших в фигуру относительно их общего количества, умноженная на
площадь объемлющего прямоугольника:
\begin{equation*}
  S_\textrm{Ф} = \frac{n_\textrm{внутр}}{n_\textrm{всего}} \cdot S_\textrm{П}
\end{equation*}

Напишите программу, вычисляющую внутреннюю площадь эллипса. В качестве
генератора случайных чисел придумайте какую-то функцию, которая производит 
нетривиальную трансформацию своего аргумента, так что результат функции трудно
предсказуем и варьируется в значительных пределах. Для реализации программы вам
придется хранить начальное значение (seed) своего генератора случайных чисел,
принимать от него при каждом вызове, кроме сгенерированного псевдослучайного
числа, еще и новый seed. Этот seed вы должны будете хранить от вызова к вызову.
\end{enumerate}

\section*{Модуль 2. Темы 2.1-2.3}
\begin{enumerate}[{2-}1]
\item \begin{enumerate}[(a)]
\item Неподвижной точкой функции $f$ называется такое значение $f$, что 
$f(x) = x$. Её можно попробовать найти итеративной последовательностью
приближений:
\begin{equation*}
  x, f(x), f(f(x)), f(f(f(x))), \ldots
\end{equation*}

Напишите процедуру поиска неподвижной точки. Найдите с её помощью значение
золотого сечения $\phi$.

\item Описанный выше метод поиска неподвижной точки может начать осциллировать
и не сойтись, например, если искать $sqrt{a}$ как неподвижную точку функции
$x \rightarrow \frac{a}{x}$. Тем не менее, можно использовать торможение
усреднением: искать неподвижную точку не функции $f(x)$, а функции
$\frac{x+f(x)}{2}$. Реализуйте этот метод.
\end{enumerate}

\item Напишите функцию fold, которая принимает список элементов, 
функцию-бинарный оператор $op$ и начальное значение $base$, а затем применяет
$op$ к двум аргументам -- к $base$ и к первому элементу списка $x_1$. На
следующем шаге fold применяет $op$ к результату предыдущей операции и элементу
$x_2$ и так далее, в результате вычисляя формулу:
\begin{equation*}
  op~(\ldots (op~(op~base~x_1)~x_2) \ldots)~x_n
\end{equation*}

\item Напишите функцию \emph{dropWhile}, которая удаляет самый длинный префикс
(начальную часть) заданного списка, состоящий из элементов, удовлетворяющих
некоторому предикату. В качестве аргументов она принимает предикат и исходный
список, а возвращает новый список. Например:

\begin{lstlisting}
dropWhile (fun x -> x < 5) [1..10]
val it : int list = [5; 6; 7; 8; 9; 10]

dropWhile (fun x -> x > 0) [1; 2; -3; 2; 1]
val it : int list = [-3; 2; 1]

dropWhile (fun x -> x % 2 = 0) [2; 4; 1; 2; 3]
val it : int list = [1; 2; 3]

dropWhile (fun x -> x = 1) [2; 2; 1; 1]
val it : int list = [2; 2; 1; 1]

dropWhile (fun x -> x <> 0) [1..5]
val it : int list = []
\end{lstlisting}

\item \textbf{*} Напишите функцию dropWhile из упражнения 2-3, используя только
функцию fold из упражнения 2-2.
\end{enumerate}
\section*{Модуль 2. Тема 3.1}
\begin{enumerate}[{2-1}1]
\item Пусть с помощью АТД реализовано двоичное дерево поиска (все ключи левого
поддерева меньше ключа в корне; все ключи правого поддерева больше ключа
в корне). Напишите для него функцию \emph{memberOf}, которая ищет заданный
элемент в дереве и возвращает ссылку на вершину с ним либо какое-то
уведомление об отсутствии (например, Nil-вершину).

\item Выражения логики высказываний можно задать с помощью следующего АТД:
  \begin{lstlisting}
    type proposition =
    | True
    | Not of proposition
    | And of proposition*proposition
    | Or of proposition*proposition
  \end{lstlisting}
  \begin{enumerate}[(a)]
  \item Добавьте в АТД поддержку переменных.
  \item Напишите функцию $isTautology~:~proposition \rightarrow bool$, которая
    проверяет, является ли заданое выражение тавтологией, т.е. принимает
    истинное значение на всех наборах значений своих переменных.  
  \end{enumerate}

\item Опишите тип данных $Rope<’a, ’b>$ -- список, который хранит элементы 
двух типов, чередуя их друг за другом. Компилятор должен сам проверять каждый
экземпляр Rope на корректность конструкции. Т.е. строчка
\begin{lstlisting}
  let value = Node("str0", Node(0, 
              Node("str1", Node(1, Node(2, Nil)))))
\end{lstlisting}
скомпилироваться не должна, потому что нарушен порядок чередования.

\item Реализуйте для АТД $Rope$ функцию $length$, которая возвращает кортеж
из двух чисел: количество элементов 1-го и 2-го типа.

\item Для бинарного дерева реализовать следующие функции:
  \begin{enumerate}[(a)]
  \item Высота дерева.
  \item Количество листьев.
  \item Поиск элемента, удовлетворяющего предикату. В аргументах – три 
    функции: предикат $p$, функция $whenFound$, которой нужно передать вершину
    в случае успешного поиска, и функция $whenNotFound$, которая вызывается в
    случае неуспешного.
  \item Правый поворот дерева.
  \end{enumerate}

\item \textbf{*} Реализуйте поиск удовлетворяющего элемента из п.15(c) 
  итеративно, через хвостовую рекурсию.
\end{enumerate}
\end{document}
