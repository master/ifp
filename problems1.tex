\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[T1]{fontenc}
\usepackage{amssymb,amsmath,graphicx,indentfirst}
\usepackage{caption}
\usepackage{color}
\usepackage{listings}
\usepackage{enumerate}
\usepackage[unicode]{hyperref}

\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\captionsetup[figure]{labelformat=empty}
\captionsetup[figure]{justification=centering}
\lstset{keywordstyle=\color{blue}\bfseries, basicstyle=\footnotesize}
\lstset{breaklines=true, breakatwhitespace=true}
\lstset{extendedchars=false, language=Caml, defaultdialect=[Objective]Caml}

\author{Олег Смирнов, Александр Полозов \\
\texttt{oleg.smirnov@gmail.com}, \texttt{polozov.alex@gmail.com}}
\date{\today}
\title{Введение в функциональное программирование -- задачи}

\begin{document}
\section*{Модуль 1. Темы 1.1-1.3}
\begin{enumerate}[{1-}1]
\item Напишите программу, которая выяснит, какой порядок применения функций -–
аппликативный или нормальный –- используется в F\#? То же для любого
императивного языка на ваш выбор. Подумайте, для каких задач какой порядок
применения будет предпочтительнее.

\item Напишите итеративную версию алгоритма быстрого возведения в степень по
формуле
\begin{equation*}
a^k = \left\{
\begin{array}{rl}
a^{k/2} \cdot a^{k/2} &\mbox{\textrm{если} k $\vdots$ 2} \\ 
a \cdot a^{k-1} &\mbox{\textrm{если} k $\not \vdots$ 2}
\end{array}
\right.
\end{equation*}

\item Напишите функцию проверки числа на простоту. Реализуйте рекурсивную и
итеративную версию. Хорошая скорость работы алгоритма -- порядка $O(\sqrt n)$

\item \textbf{*} Нахождение площади фигуры методом Монте-Карло заключается во
вписывании фигуры в прямоугольник и последовательной генерации большого числа
случайно выбранных точек из этого прямоугольника. Итоговой площадью считается
доля точек, попавших в фигуру относительно их общего количества, умноженная на
площадь объемлющего прямоугольника:
\begin{equation*}
  S_\textrm{Ф} = \frac{n_\textrm{внутр}}{n_\textrm{всего}} \cdot S_\textrm{П}
\end{equation*}

Напишите программу, вычисляющую внутреннюю площадь эллипса. В качестве
генератора случайных чисел придумайте какую-то функцию, которая производит 
нетривиальную трансформацию своего аргумента, так что результат функции трудно
предсказуем и варьируется в значительных пределах. Для реализации программы вам
придется хранить начальное значение (seed) своего генератора случайных чисел,
принимать от него при каждом вызове, кроме сгенерированного псевдослучайного
числа, еще и новый seed. Этот seed вы должны будете хранить от вызова к вызову.
\end{enumerate}

\section*{Модуль 2. Тема 2.1}
\begin{enumerate}[{2-}1]
\item \begin{enumerate}[(a)]
\item Неподвижной точкой функции $f$ называется такое значение $f$, что 
$f(x) = x$. Её можно попробовать найти итеративной последовательностью
приближений:
\begin{equation*}
  x, f(x), f(f(x)), f(f(f(x))), \ldots
\end{equation*}

Напишите процедуру поиска неподвижной точки. Найдите с её помощью значение
золотого сечения $\phi$.

\item Описанный выше метод поиска неподвижной точки может начать осциллировать
и не сойтись, например, если искать $sqrt{a}$ как неподвижную точку функции
$x \rightarrow \frac{a}{x}$. Тем не менее, можно использовать торможение
усреднением: искать неподвижную точку не функции $f(x)$, а функции
$\frac{x+f(x)}{2}$. Реализуйте этот метод.
\end{enumerate}

\item Напишите функцию fold, которая принимает список элементов, 
функцию-бинарный оператор $op$ и начальное значение $base$, а затем применяет
$op$ к двум аргументам -- к $base$ и к первому элементу списка $x_1$. На
следующем шаге fold применяет $op$ к результату предыдущей операции и элементу
$x_2$ и так далее, в результате вычисляя формулу:
\begin{equation*}
  op~(\ldots (op~(op~base~x_1)~x_2) \ldots)~x_n
\end{equation*}

\item Напишите функцию \emph{dropWhile}, которая удаляет самый длинный префикс
(начальную часть) заданного списка, состоящий из элементов, удовлетворяющих
некоторому предикату. В качестве аргументов она принимает предикат и исходный
список, а возвращает новый список. Например:

\begin{lstlisting}
dropWhile (fun x -> x < 5) [1..10]
val it : int list = [5; 6; 7; 8; 9; 10]

dropWhile (fun x -> x > 0) [1; 2; -3; 2; 1]
val it : int list = [-3; 2; 1]

dropWhile (fun x -> x % 2 = 0) [2; 4; 1; 2; 3]
val it : int list = [1; 2; 3]

dropWhile (fun x -> x = 1) [2; 2; 1; 1]
val it : int list = [2; 2; 1; 1]

dropWhile (fun x -> x <> 0) [1..5]
val it : int list = []
\end{lstlisting}

\item \textbf{*} Напишите функцию dropWhile из упражнения 2-3, используя только
функцию fold из упражнения 2-2.
\end{enumerate}

\section*{Модуль 2. Тема 2.2}

\begin{enumerate}[{2-}1]
  \setcounter{enumi}{4}
\item Реализовать списочные комбинаторы. Просто имя без комментариев означает 
  одноименный стандартный комбинатор модуля List.
  \emph{Примечание:} если можно, реализовать сразу итеративно.
  \begin{enumerate}[(a)]
  \item $init$
  \item $append$ (он же @)
  \item $collect$, также известный как $flatMap$
  \item $partition$
  \item $permute$
  \item $skipWhile$ -- выкидывает из списка длиннейший префикс, в котором все 
    элементы удовлетворяют заданному предикату; возвращает остальное.
    \begin{lstlisting}
      skipWhile (fun x -> x < 3) [1..5];;
      val it: int list = [3; 4; 5]
    \end{lstlisting}
  \item $compressOn$ –- сжимает в данном списке группы подряд идущих элементов,
    равных согласно заданному компаратору, до одного представителя. Конкретный 
    выбор представителей зависит от реализации. Один из вариантов работы:
    \begin{lstlisting}
      let equalsParity x y = x % 2 = y % 2;;
      compressOn equalsParity [1; 3; 4; 5; 9; 11; 6; 0; 0];;
      val it : int list = [3; 4; 11; 0]
    \end{lstlisting}
  \item $pairwise$ -– порождает список последовательных пар элементов.
    \begin{lstlisting}
      pairwise [1..5];;
      val it : (int * int) list = [(1, 2); (2, 3); (3, 4); (4, 5)]
    \end{lstlisting}
  \item $windowed$ –- обобщение $pairwise$, порождает последовательные подсписки 
    заданной длины $k$.
    \begin{lstlisting}
      windowed 3 [1..5];;
      val it : int list list = [[1; 2; 3]; [2; 3; 4]; [3; 4; 5]]
    \end{lstlisting}
  \end{enumerate}

\item Написать функцию, порождающую список перестановок заданного списка в 
  каком-либо порядке.
  \begin{lstlisting}
    permute [1..3];;
    val it : int list list = [[1; 2; 3]; [1; 3; 2]; [2; 1; 3]; [2; 3; 1]; [3;1; 2]; [3; 2; 1]]
  \end{lstlisting}

\item Написать оператор суперпозиции, принимающий список функций и возвращающий
  единственную функцию, которая принимает аргумент $x$ и последовательно
  ``цепочкой'' применяет к нему все функции из списка, передавая выходное 
  значение $(i-1)$-й функции на вход $i$-й.
  
\item Задан список списков чисел. ``Вытянуть'' его в один список.
  \begin{lstlisting}
    flatten [[1..3]; [5..7]];;
    val it : int list = [1; 2; 3; 5; 6; 7]
  \end{lstlisting}
  
\item Реализовать функцию $flatten$ для списков списков глубины вложенности
  более $1$. Если у вас не получается, подумайте, почему.

\item Будем представлять матрицы по рядкам -– как списки списков одинаковой 
  длины. Реализовать:
  \begin{enumerate}[(a)]
  \item Произведение матрицы на вектор (т.е. список).
  \item Произведение матриц.
  \item Транспонирование матрицы.
  \item \textbf{*} Возведение матрицы в степень $k$, с логарифмической идеей,
    как на первой лекции. Какая оценка времени работы теперь будет у алгоритма?
  \item  Метод Гаусса.
  \end{enumerate}
  
\item Реализовать списочные комбинаторы без применения функции переворота 
  списка:
  \begin{enumerate}[(a)]
  \item $takeWhileEnd$ –- возвращает длиннейший суффикс списка, в котором все
    элементы удовлетворяют заданному предикату.

  \item $skipWhileEnd$ –- выкидывает из списка длиннейший суффикс, в котором 
    все элементы удовлетворяют заданному предикату; возвращает остальное.
  \end{enumerate}
\end{enumerate}

\section*{Модуль 2. Тема 2.3}
\begin{enumerate}[{2-}1]
  \setcounter{enumi}{11}

\item Пусть с помощью АТД реализовано двоичное дерево поиска (все ключи левого
  поддерева меньше ключа в корне; все ключи правого поддерева больше ключа
  в корне). Напишите для него функцию \emph{memberOf}, которая ищет заданный
  элемент в дереве и возвращает ссылку на вершину с ним либо какое-то
  уведомление об отсутствии (например, Nil-вершину).
  
\item Выражения логики высказываний можно задать с помощью следующего АТД:
  \begin{lstlisting}
    type proposition =
    | True
    | Not of proposition
    | And of proposition*proposition
    | Or of proposition*proposition
  \end{lstlisting}
  \begin{enumerate}[(a)]
  \item Добавьте в АТД поддержку переменных.
  \item \textbf{*} Напишите функцию 
    $isTautology~:~proposition \rightarrow bool$, которая
    проверяет, является ли заданое выражение тавтологией, т.е. принимает
    истинное значение на всех наборах значений своих переменных.  
  \end{enumerate}

\item Опишите тип данных $Rope<’a, ’b>$ -- список, который хранит элементы 
двух типов, чередуя их друг за другом. Компилятор должен сам проверять каждый
экземпляр Rope на корректность конструкции. Т.е. строчка
\begin{lstlisting}
  let value = Node("str0", Node(0, Node("str1", Node(1, Node(2, Nil)))))
\end{lstlisting}
скомпилироваться не должна, потому что нарушен порядок чередования.

\item Реализуйте для АТД $Rope$ функцию $length$, которая возвращает кортеж
из двух чисел: количество элементов 1-го и 2-го типа.

\item Для бинарного дерева реализовать следующие функции:
  \begin{enumerate}[(a)]
  \item Высота дерева.
  \item Количество листьев.
  \item Поиск элемента, удовлетворяющего предикату. В аргументах – три 
    функции: предикат $p$, функция $whenFound$, которой нужно передать вершину
    в случае успешного поиска, и функция $whenNotFound$, которая вызывается в
    случае неуспешного.
  \item Правый поворот дерева.
  \end{enumerate}

\item \textbf{*} Реализуйте поиск удовлетворяющего элемента из п.2-16(c) 
  итеративно, через хвостовую рекурсию.
\end{enumerate}
\end{document}
